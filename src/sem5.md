# Semana 5 - Iteradores

<div class="aims">
<div class="aims_header">
‚úîÔ∏è Objetivos
</div>

* Identificar los casos de uso de un iterador.

* Conocer la implementaci√≥n de los iteradores en las distintas implementaciones del TAD Lista.

* Conocer la noci√≥n de iterador como abstracci√≥n de puntero.

* Aplicar las clases de la STL para realizar problemas concretos.
    
<div class="aims_header">
‚úîÔ∏è Tiempo de estudio
</div>

* **V√≠deos**: 48min (+3 min opcional)

* **Total** *(incluyendo v√≠deos, cuestionarios y actividades de autoevaluaci√≥n)*: 2h

</div>

## 5.1. Motivaci√≥n. ¬øPara qu√© sirven los iteradores?

Los iteradores son unos Tipos Abstractos de Datos muy utilizados para recorrer listas. Permiten a un programador moverse secuencialmente por los elementos de una lista, independientemente de si la lista est√° implementada mediante un vector o mediante una lista enlazada.


<div class="exercise">
<div class="title">
üìù Ejercicio 5.1
</div>
<div class="body">

Para entender mejor la utilidad de los iteradores, comienza por el siguiente cuestionario:

‚ùì [Cuestionario de autoevaluaci√≥n - ¬øPara qu√© sirve un iterador?](quizzes/sem05_1.md)

</div>
</div>

Ahora veamos para qu√© sirve el TAD Iterador y cu√°les son las operaciones que soporta.

‚ñ∂Ô∏è [Introducci√≥n a los iteradores](https://youtu.be/W2BlFbgP6Ys) (9:41) 

## 5.2. Iteradores en listas enlazadas

La primera implementaci√≥n de iteradores que veremos ser√° en el contexto de la clase `ListLinkedDouble`. En este caso, un iterador contiene un puntero al nodo que est√° siendo se√±alado actualmente por el iterador.

‚ñ∂Ô∏è [Iteradores y listas enlazadas](https://youtu.be/NkLadw80I4E) (5:30)

üìÑ [C√≥digo fuente](https://github.com/manuelmontenegro/ED/blob/main/lineales/list_linked_double_v6/list_linked_double.h)

Vamos a hacer un peque√±o inciso sobre un aspecto de C++ que no est√° cubierto en los v√≠deos. Observa el constructor de la clase `iterator` en el c√≥digo fuente de `ListLinkedDouble`. ¬°Es un constructor privado!. En primer lugar, ¬øpor qu√© es privado?. En segundo lugar, ¬øc√≥mo creo instancias de `iterator` si su constructor es privado?. Respondemos a estas preguntas a continuaci√≥n: 

* **¬øPor qu√© es privado?** Por dos motivos. El primero es porque queremos que un/a
   usuario/a de la clase `ListLinkedDouble` solamente pueda obtener iteradores
   llamando a los m√©todos `begin` y `end`. El segundo motivo se debe a que el
   cliente de la clase `ListLinkedDouble` no tiene acceso al tipo `Node`, ya que
   su definici√≥n tambi√©n es privada (y as√≠ debe seguir si√©ndolo). Por
   tanto, ¬øc√≥mo podr√≠a un/a programador/a crear un iterador directamente, si
   no tiene ning√∫n puntero a `Node` con el que llamar a su constructor? Y si,
   aun as√≠, tuviese acceso al tipo `Node` ¬øqu√© garantiza que el/la
   programador/a vaya a crear un iterador de manera correcta?. Por estos
   motivos, es mejor encapsular la creaci√≥n de iteradores exclusivamente
   mediante el uso de los m√©todos `begin` y `end`. 

* **¬øC√≥mo creo instancias de `iterator`?** En general, no es posible acceder a
     los m√©todos y atributos privados de una clase desde fuera de ella, pero
     hemos hecho un peque√±o ¬´truco¬ª. La clave est√° en la siguiente
     [declaraci√≥n](https://github.com/manuelmontenegro/ED/blob/9e5fe90e3799eb72228222869c6fd98d618f1af7/lineales/list_linked_double_v6/list_linked_double.h#L140) dentro de la clase `iterator`: 

     ```cpp
     friend class ListLinkedDouble;
     ```

     Con esto estamos diciendo que la clase `ListLinkedDouble` es *amiga* de
     `iterator`. Esto significa que la clase `ListLinkedDouble` puede acceder
     a los atributos y m√©todos privados de la clase `iterator`. Por este
     motivo, en los m√©todos `begin` y `end` hemos podido llamar a los
     constructores de `iterator`, aunque sean privados. En general, C++ nos
     permite declarar clases y funciones amigas de una determinada clase `A`.
     Estas clases y funciones podr√°n acceder, en su c√≥digo, a los atributos y
     m√©todos privados de `A`. F√≠jate en que la declaraci√≥n `friend` debe
     estar *dentro* de la definici√≥n de la clase `A`. Con esto nos aseguramos
     de que la persona que ha creado la clase `A` indica expresamente qui√©nes
     son las amigas de la clase. 

<div class="exercise">
<div class="title">
üìù Ejercicio 5.2
</div>
<div class="body">

 Los iteradores nos permiten hacer referencia a posiciones arbitrarias dentro de una lista. 

* ¬øPuedes escribir un m√©todo dentro de `ListLinkedDouble` que inserte un elemento antes de la posici√≥n indicada por un iterador?

* ¬øPuedes escribir un m√©todo que elimine el elemento se√±alado por un iterador?


üíª [Ejercicio: inserci√≥n y eliminaci√≥n de elementos en una lista](https://godbolt.org/z/Mzxs4vdTb)

</div>
</div>

En el siguiente v√≠deo se explica la soluci√≥n. Ten en cuenta que las implementaciones que se detallan all√≠ no solo realizan la inserci√≥n/borrado correspondientes, sino que tambi√©n devuelven otro iterador. Es importante saber por qu√©.

‚ñ∂Ô∏è [Inserci√≥n y borrado con iteradores](https://youtu.be/GOMNAzVbCZk) (3:16)

De este v√≠deo se extrae un importante resultado: 

<div class="warning">

**Aviso**

Las operaciones que insertan o eliminan elementos de una lista pueden afectar, o incluso **invalidar**, los iteradores que actualmente existan sobre esa lista.

</div>

 Uno de los principales errores del principiante es, precisamente, el acceso a iteradores invalidados. Cuando veamos la STL m√°s adelante, veremos c√≥mo saber qu√© operaciones sobre listas alteran o invalidan a los iteradores existentes. 

 <div class="exercise">
<div class="title">
üìù Ejercicio 5.3
</div>
<div class="body">

En el siguiente cuestionario podr√°s practicar todo lo visto hasta ahora:

‚ùì [Cuestionario de autoevaluaci√≥n - Iteradores sobre listas](quizzes/sem05_2.md)

</div>
</div>

En el siguiente v√≠deo vamos a ver la relaci√≥n que existe entre los iteradores y el modificador `const`. A partir del minuto 4:20 se explican unos detalles de implementaci√≥n. Si te pierdes en esos detalles, no te preocupes; no es esencial para la asignatura.

‚ñ∂Ô∏è [Iteradores constantes](https://youtu.be/-TE-3-3DEWk) (5:59)

üìÑ [C√≥digo fuente](https://github.com/manuelmontenegro/ED/blob/main/lineales/list_linked_double_v7/list_linked_double.h)

Ahora viene una parte bonita, conocida como el *az√∫car sint√°ctico*. En el siguiente v√≠deo vamos a renombrar los m√©todos `advance` y `elem` que hemos definido hasta ahora, con el objetivo de acercar la sintaxis que estamos utilizando a la sintaxis de los punteros de C++. Tambi√©n aprovechamos para presentar el especificador `auto` y la sintaxis de los bucles `for` que hacen uso de iterador.

‚ñ∂Ô∏è [Adaptando la sintaxis de los iteradores](https://youtu.be/Prx6lK-C1Mg) (7:13)

üìÑ [C√≥digo fuente](https://github.com/manuelmontenegro/ED/blob/main/lineales/list_linked_double_v8/list_linked_double.h)


## 5.3. Iteradores en arrays

De nuevo, seguimos en el TAD Lista, pero ahora en su implementaci√≥n mediante vectores. Gracias a la sintaxis que hemos empleado en el √∫ltimo v√≠deo (el operador `*` en lugar del m√©todo `elem` y el operador `++` en lugar del m√©todo `advance`), la incorporaci√≥n de iteradores a esta implementaci√≥n es extremadamente simple.

Ojo a la parte final del video, que explica por qu√© los iteradores son una generalizaci√≥n de los punteros.

‚ñ∂Ô∏è [Iteradores en ListArray](https://youtu.be/vrNJ-575-g4) (4:01)

El concepto de iterador es omnipresente en el lenguaje C++. Hemos visto que existen iteradores para *strings*. En la secci√≥n siguiente veremos que tambi√©n existen iteradores para flujos de salida (`ofstream` y compa√±√≠a). De momento, vamos a practicar un poco los iteradores sobre cadenas con un par de ejercicios:

<div class="exercise">
<div class="title">
üìù Ejercicio 5.4 - Pasar una cadena a may√∫sculas
</div>
<div class="body">

La funci√≥n `toupper`, definida en el fichero de cabecera `<cctype>`, recibe un car√°cter y devuelve su car√°cter equivalente en may√∫sculas. Utilizando iteradores sobre cadenas, extiende esta funci√≥n para que transforme todos los caracteres de una cadena a may√∫sculas:

üíª [Ejercicio - Pasar una cadena a letras may√∫sculas](https://godbolt.org/z/jGT4GYYe8)

üíª [Soluci√≥n](https://godbolt.org/z/v4eEj6ajb)

</div>
</div>


<div class="exercise">
<div class="title">
üìù Ejercicio 5.5 - Cadenas ¬´cochanbrosas¬ª
</div>
<div class="body">

Decimos que una cadena es *cochanbrosa* (sic) si contiene una letra `n` antes de una letra `p`, o antes de una letra `b`. Por ejemplo: `"Inb√©cil"`, `"Colonbia"`. Escribe una funci√≥n que determine si una cadena es cochanbrosa. Para ello utiliza dos iteradores que recorran simult√°neamente la lista.

üíª [Ejercicio - Cadenas cochanbrosas](https://godbolt.org/z/aszbYGG1d)

üíª [Soluci√≥n](https://godbolt.org/z/7Yzc845v1)

</div>
</div>

## 5.4. Introducci√≥n a la STL

El acr√≥nimo STL proviene de Standard Template Library. La STL forma parte de la librer√≠a est√°ndar de C++ y consiste, b√°sicamente, en un conjunto de clases que implementan los Tipos Abstractos de Datos que hemos visto este curso, y algunos TADs m√°s que nos quedan por ver. Adem√°s de eso, la STL implementa una gran cantidad de algoritmos que trabajan sobre estos TADs: ordenaci√≥n, b√∫squeda, etc.

En efecto, todo lo que hemos visto sobre los TADs Lista, Pila, Cola y Doble Cola ya est√° implementado. Tambi√©n todo lo relacionado con los iteradores. A partir de ahora os voy a pedir que utilic√©is las clases de la STL para realizar los problemas que requieran el uso de estos TADs, en lugar de las implementaciones que os he ido proporcionando estas semanas. Pero ¬°ojo!, si en alg√∫n ejercicio os pido a√±adir alguna operaci√≥n que requiera acceso a la representaci√≥n interna de los TADs, entonces s√≠ que deb√©is utilizar las implementaciones que hemos ido desarrollando en los v√≠deos de estas semanas.

Aunque la interfaz de los TADs de la STL es siempre es la misma, las implementaciones concretas dependen del compilador que utilic√©is, y adem√°s suelen ser bastante cr√≠pticas debido al gran n√∫mero de optimizaciones y caracter√≠sticas avanzadas de C++ de las que hacen uso.

Pero entonces, si todo esto est√° ya implementado, ¬øpor qu√© hemos estado perdiendo el tiempo implement√°ndolo nosotros/as?. En realidad, no hemos estado perdiendo el tiempo. Uno de los objetivos de este curso es conocer la implementaci√≥n interna de estos TADs para poder tener una decisi√≥n informada sobre qu√© implementaci√≥n nos conviene para seg√∫n qu√© prop√≥sito.

Dicho todo esto, vamos a iniciar nuestro estudio de los TADs de la STL, pero antes te voy a dar la oportunidad de que la explores t√∫ mismo/a.

<div class="exercise">
<div class="title">
üìù Ejercicio 5.6
</div>
<div class="body">

Accede al siguiente enlace:

üåé [Librer√≠a de contenedores](https://en.cppreference.com/w/cpp/container)

Investiga un poco las clases que est√°n bajo el apartado *Sequence containers* y *Container adaptors*. A continuaci√≥n, resuelve el siguiente cuestionario:

‚ùì [TADs lineales en la STL - Cuestionario previo](quizzes/sem05_3.md)

</div>
</div>

Ahora s√≠, los v√≠deos:

‚ñ∂Ô∏è [C++ - Contenedores lineales en la STL](https://youtu.be/p0lGTTcN7PE) (3:06)

‚ñ∂Ô∏è [C++ - Iteradores en la STL](https://youtu.be/jyO3QMIavrI) (3:46)

‚ñ∂Ô∏è [C++ - Algoritmos en la STL (1)](https://youtu.be/RRh-JFxMl2c) (4:58) 

<div class="exercise">
<div class="title">
üìù Ejercicio 5.7
</div>
<div class="body">

Aqu√≠ tienes un ejemplo para que puedas ir practicando con los algoritmos de la STL:

üíª [Ejercicio: algoritmos de la STL](https://godbolt.org/z/YfoPrx3d8)

üíª [Soluci√≥n](https://godbolt.org/z/xK4TfPvGM)

</div>
</div>

Queda comentar un √∫ltimo aspecto de la STL que es important√≠simo tener en cuenta a la hora de trabajar con los iteradores. De nuevo, accede a la siguiente p√°gina:

üåé [Librer√≠a de contenedores](https://en.cppreference.com/w/cpp/container)

Observa la secci√≥n *Iterator invalidation*. La tabla nos dice qu√© iteradores se invalidan a la hora de hacer una modificaci√≥n sobre un determinado TAD. Debes recordar lo siguiente:


* Tras hacer una inserci√≥n en un objeto de la clase `list`, los iteradores que hubiese sobre esa lista **siguen siendo v√°lidos**. Si se realiza un borrado, tambi√©n siguen siendo v√°lidos **excepto si apuntan al elemento borrado**.

* Tras hacer una inserci√≥n en un objeto de la clase `vector`, si el array se redimensiona, todos los iteradores quedan invalidados. Si no se redimensiona, solo los iteradores que apunten antes del elemento insertado se mantienen v√°lidos; los que apuntan despu√©s del elemento insertado quedan invalidados. Lo mismo se aplica a los borrados. Para un/a usuario/a de la clase `vector` resulta dif√≠cil predecir de antemano cu√°ndo se produce un redimensionado del array, por lo que normalmente hay que suponer que, cuando se realiza una inserci√≥n o borrado en un `vector`, **todos los iteradores se invalidan**.

<div class="exercise">
<div class="title">
üìù Ejercicio 5.8
</div>
<div class="body">

Finalizamos nuestro viaje por la STL con un cuestionario: 

‚ùì [Cuestionario de autoevaluaci√≥n - STL (1)](quizzes/sem05_4.md)

</div>
</div>

## 5.5. TADs en la librer√≠a est√°ndar de Java (Opcional)

Aunque este curso est√° centrado en C++, seguramente utilizas Java en otras asignaturas. Te dejo un breve v√≠deo con las clases que necesitas conocer para utilizar los TADs vistos hasta ahora en Java.

‚ñ∂Ô∏è [Java - TADs Lineales](https://youtu.be/OtaCEwlZb_U) (Opcional) (3:02)

## 5.6. Problemas de laboratorio

<div class="exercise">
<div class="title">
üìù Ejercicio 5.9
</div>
<div class="body">

üíª [Matriz de Toeplitz](assignments/L05-1.pdf)

</div>
</div>

<div class="exercise">
<div class="title">
üìù Ejercicio 5.10
</div>
<div class="body">

üíª [De postre, un chulet√≥n](assignments/L05-2.pdf)

</div>
</div>

<div class="exercise">
<div class="title">
üìù Ejercicio 5.11
</div>
<div class="body">

üíª [Suavizar una lista de n√∫meros enteros](assignments/L05-3.pdf)

</div>
</div>